<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>aleks5d blog</title>
	<link rel="stylesheet" href="header.css">
	<link rel="stylesheet" href="blog.css">
	<link rel="stylesheet" href="main.css">
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
</head>
<body>
	<header>
		<ul>
		    <li><a href="index.html">Блог</a></li>
		    <li><a href="#algo.html">Алгоритмы</a></li>
		</ul>
	</header>
	<main>
		<div class = "blogHeader">
			LCA-1
		</div>
		<div class = "blogMain">
<h1>LCA - lowest (least) common ancestor<br>
Наименьший общий предок двух вершин</h1>
<p>
Для начала давайте разберемся, что такое общий предок двух вершин \(u\) и \(v\).<br>
Это любая такая вершина \(t\), которая лежит на пути от корня до \(u\) и на пути от корня до \(v\).
</p>
<p>
Тогда наименьшим общим предком \(u\) и \(v\) назовем такую вершину \(t\), которая является их общим предком, и расстояние от корня до нее максимально.
</p>
<p>
Зачем нужно уметь его искать? <br>
В последнее время я все реже встречаю задачи, требующие именно явного нахождения наименьшего общего предка, но порой попадаются задачи про запросы на пути, а с ними нам может помочь LCA.
</p>
<h3>Наивная реализация</h3>
<p>
Для начала рассмотрим самую простую реализацию поиска LCA:
</p>
<pre><code>
	vector&lt;vector&lt;int&gt;&gt; gr; \\ наш граф
	vector&lt;int&gt; pre; \\ массив предков
	vector&lt;int&gt; d; \\ массив глубин

	void dfs(int v, int p = -1) {
		if (p == -1)
			d[v] = 0;
		else
			d[v] = d[p] + 1;
		pre[v] = p;
		for (int to : gr[v]) 
			if (to != p)
				dfs(to, v);
	}

	int getLCA(int a, int b) {
		while (a != b) {
			if (d[a] > d[b]) 
				a = pre[a];
			else
				b = pre[b];
		}
		return a;
	} 

	int main() {
		... // считываем граф
		dfs(root) // запускаем дфс от корня

		for () {
			... // считываем запрос
			getLCA(a, b); // отвечаем на него
		}
	}
</code></pre>
<p>
	Почему это верно? 
</p>
<p>
	Давайте посмотрим, что делает наш алгоритм. Пусть сейчас выбраны вершины \(a\) и \(b\).<br>
	Их LCA имеет глубину не больше, чем минимум из глубин \(a\) и \(b\), так как лежит на пути от корня до этих вершин.<br>	
	Значит, если глубины вершин неравны, то можно смело заменять более глубокую вершину ее предком.<br>
	Теперь допустим, что глубины вершин одинаковы.<br>
	Тогда если они равны, то очевидно что это и есть LCA.<br>
	Иначе, LCA имеет губину меньшую, чем та, на которой сейчас расположены вершины, и опять можно заменить их своими предками.<br>
</p>
<p>
	Отлично, теперь давайте оценим время работы.<br>
	dfs() отработает за O(n)<br>
	getLCA() в худшем случае будет работать за O(n) (например, если граф - бамбук, и мы спрашиваем ответ от его концов)<br>
	Таким образом, алгоритм работает за O(q * n) - достаточно долго.<br>
</p>
<p>
	Давайте попробуем ускорить наш алгоритм.
</p>
<h3>Метод двоичных подъёмов</h3>
<p>
Если очень внимательно посмотреть на предыдущую реализацию, то можно заметить два этапа в ней:
</p>
<p>
Первый - глубина вершин выравнивается.
</p>
<p>
Второй - вершины параллельно поднимаются наверх, пока не станут равными.
</p>
<p>
Тогда давайте ходить не по 1, а большими блоками. Например, степенями двойки.
</p>
<p>
Для начала разберемся, как их предпосчитать.
</p>
<p><pre><code>
	vector&lt;vector&lt;int&gt;&gt; gr;
	vector&lt;int&gt; d;
	vector&lt;vector&lt;int&gt;&gt; bl; // бинарные подъемы
	// этот массив следует инициализировать так: bl[log(n)+1][n]
	// log(n)+1 ассив по n элементов

	void dfs(int v, int p = -1) {
		if (p == -1) { 
			p = v;
			d[v] = 0;
		} 
		else
			d[v] = d[p] + 1;
		bl[0][v] = p;
		for (int i = 1; i < bl.size(); ++i)
			bl[i][v] = bl[i-1][bl[i-1][v]];
		for (int to : gr[v])
			dfs(to, v);
	}
</code></pre></p>
<p>
Почему это работает? В цикле построения bl мы говорим, что подняться на \(2^i\) то же самое, что подняться на \(2^{i-1}\) два раза.
</p>
<p>
Как можно заметить, в такой реализации нельзя подняться выше корня, а значит, не нужны дополнительные if.
</p>
<p>
Как же тут отвечать на запрос? Давайте разбираться.<br>
</p>
<p><pre><code>
	int getLCA(int a, int b) {
		if (d[a] > d[b])
			swap(a, b); 
		// Теперь b глубже a
		for (int i = bl.size() - 1; i >= 0; --i) 
			if (d[bl[i][b]] >= d[a])
				b = bl[i][b];
		// Теперь их глубины равны
		if (a == b)
			return a; // Если они равны, то это и есть LCA

		for (int i = bl.size() - 1; i >= 0; --i)
			if (bl[i][b] != bl[i][a]) {
				a = bl[i][a];
				b = bl[i][b];
			}
		//Теперь верно, что a != b и их глубина минимальна
		return bl[0][a];
	}
</code></pre></p>
<p>
Теперь есть два варианта:<br>
Первый - вы верите мне, что это работает. Тогда делайте <a href = "#skip1">*ТЫК*</a> и читайте дальше<br>
Второй - вы хотите понять, что вообще произошло. Тогда продолжайте читать дальше.
</p>
<p>
Для начала докажем, что работает первый этап и глубина b становится равной глубине a.
</p>
<p>
Рассмотрим число \(x = (d[b] - d[a])\),<br> тогда когда мы пойдем от меньшего бита к большему, мы будем совершать переход только тогда, когда этот бит есть в числе.<br>
Почему? Потому что если степень двойки больше, чем максимальный бит числа, то эта степень точно больше самого числа.<br>
Значит, мы будем всегда совершать переход по самому большому биту числа.<br>
После этого расстояние уменьшится на эту степень двойки, и мы перейдем к меньшему расстоянию, с которым по аналогии возьмем переход в соответствии с максимальным битом.
Кстати, на этом можно основать некоторую оптимизацию. Вместо цикла <br>
<pre><code>
	for (int i = bl.size() - 1; i >= 0; --i)
		if (d[bl[i][b]] >= d[a])
			b = bl[i][b];
</code></pre>
писать 
<pre><code>
	int x = d[b] - d[a];
	for (int i = bl.size() - 1; i >= 0; --i)
		if (x & (1 << i))
			b = bl[i][b];
</code></pre>
Так как тут меньше операций и они более простые, то и работать будет быстрее (чуть-чуть).
</p>
<p>
А что происходит на втором этапе?  
</p>
<p>
Вообще, мы хотим максимально подняться так, чтобы a было все еще не было равно b.
</p>
<p>
Значит, есть какая-то глубина x, на которую нам хотелось бы подняться, но мы ее не знаем. У нас есть условие \(a \neq b\), которое мы и будем использовать. 
</p>
<p>
Опять таки, мы не можем перейти по биту больше, чем максимальный, а по максимальному можем всегда. Так мы поднимемся максимально и сохраним \(a\neq b\), а значит, их предок уже таков, что \(pre[a] = pre[b]\), следовательно, это и есть LCA.
</p>
<h4><a name="skip1">Что еще умеют бинподъемы?</a></h4>
<p>
Например, можно посчитать какую-то функцию на пути, параллельно с поиском LCA.
</p>
<p>
Для этого давайте хранить bl как массив пар вида \( [to, f] \) - куда нужно перейти, и какое значение функции на этом переходе. 
</p>
<p>
Покажу на примере минимума. Он хорош тем, что нельзя брать его на пути до корня, а потом вычитать ответ на пути от LCA до корня.<br> 
Например, сумму можно считать так: если \(sum[v]\) - сумма на пути до вершины v, то сумма на пути от a до b считается как \(sum[a] + sum[b] - 2 * sum[LCA]\). Это если значения записаны на ребрах.<br> С минимумом так не выйдет.
</p>
<p><pre><code>
	vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; gr;
	vector&lt;int&gt; d;
	vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; bl;

	void dfs(int v, int p = -1, int pEdge = inf) {
		if (p == -1) { 
			p = v;
			d[v] = 0;
		}
		else
			d[v] = d[p] + 1;
		bl[0][v] = {p, pEdge};
		for (int i = 1; i < bl.size(); ++i)
			bl[i][v] = {bl[i-1][bl[i-1][v].first].first, min(bl[i-1][v].second, bl[i-1][bl[i-1][v].first].second);
		for (pair&lt;int, int&gt; to : gr[v])
			dfs(to.first, v, to.second);
	}

	int getMIN(int a, int b) {
		int ans = inf;

		if (d[a] > d[b])
			swap(a, b); 
		for (int i = bl.size() - 1; i >= 0; --i) 
			if (d[bl[i][b].first] >= d[a]) {
				ans = min(ans, bl[i][b].second);
				b = bl[i][b].first;
			}
		if (a == b)
			return ans;

		for (int i = bl.size() - 1; i >= 0; --i)
			if (bl[i][b].first != bl[i][a].first) {
				ans = min(ans, bl[i][b].second);
				ans = min(ans, bl[i][a].second);
				a = bl[i][a].first;
				b = bl[i][b].first;
			}
		ans = min({ans, bl[i][b].second, bl[i][a].second});
		return ans;
	}
</code></pre></p>
<p>
Ну и самое важное: время и память!<br>
Как можно заметить, алгоритм требует \(O(n \cdot log(n))\) памяти и \(O(n \cdot log(n))\) времени на предподсчет<br>
Но вот ответ на запрос занимает всего \(O(log(n))\)<br>
Получаем \(O(n \cdot log(n) + q \cdot log(n))\)
</p>
<h3>А как еще можно?</h3>
<p>
Можно свести LCA к RMQ и решать его любыми удобными вам методами - ДО, Sparse-table.
</p>
<p>
Как свести? Давайте выпишем Эйлеров обход графа. Тогда ответом будет вершина на полуинтервале \([min(first[a], first[b]), max(last[a], last[b]))\), глубина которой минимальна.
</p>
<p>
Здесть first и last - массивы первых и последних вхождений вершины в Эйлеров обход.
</p>
<p><pre><code>
	vector&lt;vector&lt;int&gt;&gt; gr;
	vector&lt;int&gt; d;
	vector&lt;pair&lt;int, int&gt;&gt; euler;
	vector&lt;int&gt; first;
	vector&lt;int&gt; last;

	void dfs(int v, int p = -1) {
		if (p == -1)
			d[v] = 0;
		else
			d[v] = d[p] + 1;
		first[v] = euler.size();
		euler.push_back({v, d[v]});
		for (int to : gr[v]) {
			dfs(to, v);
			euler.push_back({v, d[v]});
		}
		last[v] = euler.size();
	}
</code></pre></p>
<p>
Теперь можно взять первый элемент и минимум по вторым элементам пар на полуинтервале, это и будет LCA.
</p>
<p>
Почему так? Эйлеров обход записывает вершину в самом начале и после обхода каждого поддерева. То есть, если минимум на отрезке - какая-то вершина v, то две данные находятся в разных ее поддеревьях.
</p>
<p>
Какие плюсы и минусы?<br>
К плюсам можно отнести то, что используя столько же памяти, сколько бинарные подъемы, можно построить sparse-table и отвечать на запросы за O(1).<br>
А также, что можно использовать O(n) памяти, например - ДО.<br>	
Минусы - нельзя вычислять что-то на пути (только если это не Мо... Но это лучше даже в голову не брать.)<br>
</p>
<h3>А ещё?</h3>
<p> Есть алгоритм, требующий \(O(n)\) как памяти, так и времени на предподсчет. Отвечает на запрос он за \(O(1)\).<br>
Но рассказывать его я не буду (пока уж точно), так как он мало применим на практике и будет бесполезен на олимпиадах.</p>

<h2>ВАЖНО!</h2>
<p>
Все алгоритмы, описанные в данном тексте, умеют отвечать на запросы онлайн. Запрос пришел - мы ответили.<br>
Бинарные подъемы умеют даже добавлять вершину в дерево. Для этого нужно просто представить, что мы пришли в нее в ходе дфс, и пройтись циклом по степеням двойки.<br>
Если все запросы известны заранее, лучше использовать алгоритм Тарьяна. Про него я напишу отдельно.
</p>
		</div>
	</main>
	<footer>
		
	</footer>
</body>
</html>